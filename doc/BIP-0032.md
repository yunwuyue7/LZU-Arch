# BIP-0032

参考链接：[bips/bip-0032.mediawiki at master · bitcoin/bips](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)

## Specification: Key derivation 密钥派生规范

变量类型包括：

- 曲线阶数模数（记作n）
- 曲线点坐标
- 字节序列

标准转换函数：

- point(p)：对secp256k1基点与整数p进行EC点乘运算（重复群运算）所得坐标
- ser<sub>32</sub>(i)：32位无符号整数序列化为4字节（大端序）
- ser<sub>256</sub>(p)：整数p序列化为32字节（大端序）
- ser<sub>P</sub>(P)：坐标P=(x,y)按SEC1压缩格式序列化：(0x02或0x03) || ser<sub>256</sub>(x)，头字节取决于省略的y坐标奇偶性
- parse<sub>256</sub>(p)：32字节序列解析为256位数字（大端序）

定义从父密钥派生子密钥的函数。为避免仅依赖密钥本身，需为公私钥扩展256位熵值（称为链码）。链码在对应公私钥间相同，为32字节。

扩展私钥表示为(k, c)，其中k为常规私钥，c为链码。扩展公钥为(K, c)，其中K=point(k)，c为链码。

每个扩展密钥含2<sup>31</sup>个常规子密钥和2<sup>31</sup>个强化子密钥。子密钥索引范围：常规密钥0至2<sup>31</sup>-1，强化密钥2<sup>31</sup>至2<sup>32</sup>-1。<u>强化密钥索引简记i<sub>H</sub> = i+2<sup>31</sup></u>。

### Child key derivation (CKD) functions

#### 父私钥 → 子私钥

- <u>What is HMAC-SHA512</u>

#### 父公钥 → 子公钥

仅适用于非强化子密钥

#### 父私钥 → 子公钥

两种计算方式

- 调用CKDpriv（父私钥->子私钥） 始终有效
- 调用CKDpub （父公钥->子公钥）非强化子密钥可用

#### 父公钥 → 子私钥

不可行

### Key Identifiers 密钥标识符

标识符前32位称为密钥指纹。

### The key tree 密钥树结构

通过级联CKD函数构建树形结构。从主扩展密钥m（根节点）开始，对多个i值计算CKDpriv(m,i)得一级派生节点。每个节点均为扩展密钥，可继续应用CKDpriv。

简记法：CKDpriv(CKDpriv(CKDpriv(m,3<sub>H</sub>),2),5) 记作 m/3<sub>H</sub>/2/5。公钥同理，CKDpub(CKDpub(CKDpub(M,3),2),5) 记作 M/3/2/5。<u>存在以下恒等式（why）</u>：

- N(m/a/b/c) = N(m/a/b)/c = N(m/a)/b/c = N(m)/a/b/c = M/a/b/c
- N(m/a<sub>H</sub>/b/c) = N(m/a<sub>H</sub>/b)/c = N(m/a<sub>H</sub>)/b/c
  但 N(m/a<sub>H</sub>) 不可改写为 N(m)/a<sub>H</sub>（后者不成立）。

<u>此结构下：知晓扩展私钥可重构所有后代私钥和公钥；知晓扩展公钥可重构所有非强化后代公钥（why）</u>。

### Serialization format 序列化格式

扩展公私钥序列化规则：

- 4字节：版本字节（主网：公钥0x0488B21E，私钥0x0488ADE4；测试网：公钥0x043587CF，私钥0x04358394）
- 1字节：深度（主节点0x00，一级派生密钥0x01，依此类推）
- 4字节：父密钥指纹（主密钥为0x00000000）
- 4字节：子编号（即ser<sub>32</sub>(i)，对应x<sub>i</sub> = x<sub>par</sub>/i关系，x<sub>i</sub>为被序列化密钥；主密钥为0x00000000）
- 32字节：链码
- 33字节：公钥/私钥数据（公钥为ser<sub>P</sub>(K)，私钥为0x00 || ser<sub>256</sub>(k)）

此78字节结构按比特币标准Base58编码：先添加32位校验和（双SHA-256派生），再转为Base58字符串（111字符）。因版本字节选择，主网Base58编码以"xprv"/"xpub"开头，测试网以"tprv"/"tpub"开头。

> [!NOTE]
>
> **Base58编码方式**
> 在Base64的基础上去掉了比较容易混淆的字符：数字 0 ，大写字母 O ，小写字母 l ，大写字母 I ，以及 “+” 和 “/” 两个字符。即用0~57来编码1~9，A~Z（不含O、I）, a~z（不含l）。
>
> **Base58的编码过程是：**
>
> 1. 将要转换的数据转换为字节数组
> 2. 计算前置字节码是0的个数，因为0没必要参与转换，其结果是0。
> 3. 将256进制转换为10进制
> 4. 将10进制转换为58进制。
> 5. 得到一个58进制的数组，将第二步0的个数添加到该数组末尾。n个0就添加n个0到数组末尾。
> 6. 反转整个数组。
> 7. 查表，将base58编码转换成字符。
>
> 这里的第3步如果转换的字节数组很长，那么以256为底数的指数将会非常庞大，需要使用大数，但实际上可以优化算法，没必要一次性将整个原始数组全部转换为10进制后才转换为58进制，可采取逐个转换为58机制的策略来进行，这样可以避免使用大整数，从而提高运算效率。
